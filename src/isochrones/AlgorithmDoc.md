# Algorithm and implementation

This document contains the explanation for the algorithm and its implementation
in the pgrouting repository.

## Algorithm

Algorithm that is proposed provides a solution to the following problem:

Given a collection of edges E (a graph with vertices and adjacency matrix), a
starting vertex S and a driving distance D return all of the edges that are
reachable within D.

The problem can be solved using Dijkstra algorithm and stopping when the
element at the top of the priority queue (next shortest path element) exceeds
the driving distance D. Algorithm outputs a list of vertices (not edges) that
are reachable within D starting from a vertex S.

The output of the Dijkstra algorithm is a list of reached vertices (one can
also keep track of predecessors and cost at each vertex). In order to obtain
the edges (even edges that are not traversed in the shortest paths tree
generated by Dijkstra) one needs to traverse through all of the edges and check
if any of the vertices (source or target) defining the edge are visited. If any
of the two vertices are visited by Dijkstra then the edge needs to be
traversed. If it is possible to arrive at the next vertex in time <= D then
edge is reachable within D.

The problem gets a little bit complicated by adding several driving distance
cutoffs D1 ... Dn, directed edges, outputting the cost at virtual points and if
edge can be travelled partially (if vertex A on edge P is reached by Dijkstra,
then edge is partially travelled if going from A to its neighbor vertex B isn't
possible within D but cost at A is < D -- in this case it is possible to
traverse the edge partially and reach a virtual point somewhere on the edge).
The output is also not reachability but the cost, that has to be minimal (we
would rather include the minimum traversal of the edge).

These additions reveal several edge cases that need to be resolved:

1. Travelling the edge partially with multiple cutoffs requires keeping track
   of time while traversing a single edge (if edge is long enough then there will
   be multiple partial parts of it each ending at a particular cutoff Di).
2. If edge (A, B) is directed and D(A, B) != D(B, A) then keeping track of minimal
   traversal (including partial parts) is necessary.
3. On edge (A, B) both A and B might not be reachable. This might result in
   partial parts going from A to B and partial parts going from B to A. In this
   case it is necessary to know what output is desired in case of overlap.

Taking all of that into account it is still possible to solve the modified
problem using a single Dijkstra call.

Algorithm:

1. For a graph find all vertices reachable within Dx = max(D1, ..., Dn), keeping
   track of predecessors and minimal cost at each vertex. (Ordinary Dijkstra)
2. For each edge (A, B) in the full graph:
  2.1. Check if A or B is reached (cost(A) <= Dx). If not then edge is not in
       the output, else:
  2.2. If only one vertex is reached then traverse and output all partial parts.
    * In case of a full traversal there will be only 1 full edge.
  2.3. If both are reached and one is a predecessor of other return the minimal
       traversal (with partial parts if necessary).
  2.4. If both are reached and they have other predecessors (not each other):
    2.4.1 If both cost(A) + dist(A, B) and cost(B) + dist(B, A) are <= Dx then
          return the minimal traversal (with partial parts if needed).
    2.4.2 If 2.4.1 is not true then all results will be taken:
      * Either all partial parts going from A to B and all partial parts going
        from B to A (partial parts when joined would not form a complete edge).
      * Or a full edge (one vertex reaches the other in <= Dx) from one to the
        other and partial parts from other to the one (not reaching the target).
3. Algorithm returns the list of parts that traverse the edges (partially or
   fully) and all traversals are minimal.

## Implementation

Implementation required integrating with the `pgrouting` build system.
`pgrouting` build system is built around the fact that the library needs to
work as a postgresql plugin. This means that some parts of code
(`many_to_isochrones.c`, `isochrones.sql`) need to use the Postgres defined
functions for interfacing with the database.

Parts related to the implementation of the algorithm do not have to use
postgresql related functions and pgrouting related data structures and
algorithms. This is the case for the current implementation in
`isochrones_driver.cpp` that has its own implementation of the Dijkstra
algorithm and minimal `struct` data types. It was necessary to use some
postgres related functions to stay true to the pgrouting interface (which
unfortunately did not fully decouple the implementation of the algorithm from
the implementation of the database interface) but it is entirely possible to
avoid this and create a simpler interface with less data copying.

Dijkstra algorithm uses `std::set` as a priority queue and `std::vector` for
all the data inputs and outputs. It was necessary to remap the arbitrary edge
and vertex ids to 0-N values in order to keep the datastructures simple
(otherwise `std::unordered_map` can be used, with a performance impact).
